!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ARITHMETIC_OP_DIV	include/utility.h	/^    ARITHMETIC_OP_DIV,$/;"	m	class:ccc::Terminal
ARITHMETIC_OP_MINUS	include/utility.h	/^    ARITHMETIC_OP_MINUS,$/;"	m	class:ccc::Terminal
ARITHMETIC_OP_MULT	include/utility.h	/^    ARITHMETIC_OP_MULT,$/;"	m	class:ccc::Terminal
ARITHMETIC_OP_PLUS	include/utility.h	/^    ARITHMETIC_OP_PLUS,$/;"	m	class:ccc::Terminal
ASSIGNMENT_OP	include/utility.h	/^    ASSIGNMENT_OP,$/;"	m	class:ccc::Terminal
ArithmeticOpAutomaton	include/lexer.h	/^class ArithmeticOpAutomaton : public FiniteAutomaton {$/;"	c	namespace:ccc
ArithmeticOpAutomaton	lexer.cpp	/^ccc::ArithmeticOpAutomaton::ArithmeticOpAutomaton()$/;"	f	class:ccc::ArithmeticOpAutomaton
AssignmentOpAutomaton	include/lexer.h	/^class AssignmentOpAutomaton : public FiniteAutomaton {$/;"	c	namespace:ccc
AssignmentOpAutomaton	lexer.cpp	/^ccc::AssignmentOpAutomaton::AssignmentOpAutomaton()$/;"	f	class:ccc::AssignmentOpAutomaton
BUILTIN_TYPE_CHAR	include/utility.h	/^    BUILTIN_TYPE_CHAR,$/;"	m	class:ccc::Terminal
BUILTIN_TYPE_FLOAT	include/utility.h	/^    BUILTIN_TYPE_FLOAT,$/;"	m	class:ccc::Terminal
BUILTIN_TYPE_INT	include/utility.h	/^    BUILTIN_TYPE_INT,$/;"	m	class:ccc::Terminal
BracketAutomaton	include/lexer.h	/^class BracketAutomaton : public FiniteAutomaton {$/;"	c	namespace:ccc
BracketAutomaton	lexer.cpp	/^ccc::BracketAutomaton::BracketAutomaton()$/;"	f	class:ccc::BracketAutomaton
BuiltinTypeAutomaton	include/lexer.h	/^class BuiltinTypeAutomaton : public FiniteAutomaton {$/;"	c	namespace:ccc
BuiltinTypeAutomaton	lexer.cpp	/^ccc::BuiltinTypeAutomaton::BuiltinTypeAutomaton()$/;"	f	class:ccc::BuiltinTypeAutomaton
CHAR	include/parser.h	/^    CHAR,$/;"	m	class:ccc::Type
CHAR_PTR	include/parser.h	/^    CHAR_PTR,$/;"	m	class:ccc::Type
CHAR_PTR	include/utility.h	/^    CHAR_PTR,$/;"	m	class:ccc::Terminal
CLOSED_SCOPE	include/utility.h	/^    CLOSED_SCOPE,$/;"	m	class:ccc::Terminal
CLOSING_BRACKET	include/utility.h	/^    CLOSING_BRACKET,$/;"	m	class:ccc::Terminal
CONTROL_FLOW_BRANCH	include/utility.h	/^    CONTROL_FLOW_BRANCH,$/;"	m	class:ccc::Terminal
CONTROL_FLOW_WHILE	include/utility.h	/^    CONTROL_FLOW_WHILE,$/;"	m	class:ccc::Terminal
ControlFlowAutomaton	include/lexer.h	/^class ControlFlowAutomaton : public FiniteAutomaton {$/;"	c	namespace:ccc
ControlFlowAutomaton	lexer.cpp	/^ccc::ControlFlowAutomaton::ControlFlowAutomaton()$/;"	f	class:ccc::ControlFlowAutomaton
DEREFERENCE_OP	include/utility.h	/^    DEREFERENCE_OP,$/;"	m	class:ccc::Terminal
EXTERN	include/parser.h	/^    EXTERN,$/;"	m	class:ccc::StorageSpecifier
FILE_END	include/utility.h	/^    FILE_END,$/;"	m	class:ccc::Terminal
FLOAT	include/parser.h	/^    FLOAT,$/;"	m	class:ccc::Type
FLOAT_LITERAL	include/utility.h	/^    FLOAT_LITERAL,$/;"	m	class:ccc::Terminal
FLOAT_PTR	include/parser.h	/^    FLOAT_PTR,$/;"	m	class:ccc::Type
FLOAT_PTR	include/utility.h	/^    FLOAT_PTR,$/;"	m	class:ccc::Terminal
FUNC	include/parser.h	/^    FUNC,$/;"	m	class:ccc::Type
FiniteAutomaton	include/lexer.h	/^class FiniteAutomaton {$/;"	c	namespace:ccc
FiniteAutomaton	lexer.cpp	/^ccc::FiniteAutomaton::FiniteAutomaton()$/;"	f	class:ccc::FiniteAutomaton
FloatLiteralAutomaton	include/lexer.h	/^class FloatLiteralAutomaton : public FiniteAutomaton {$/;"	c	namespace:ccc
FloatLiteralAutomaton	lexer.cpp	/^ccc::FloatLiteralAutomaton::FloatLiteralAutomaton()$/;"	f	class:ccc::FloatLiteralAutomaton
FunctionNode	include/parser.h	/^    struct FunctionNode : SyntaxTreeNode {$/;"	s	class:ccc::SyntaxTree
ID	include/utility.h	/^    ID,$/;"	m	class:ccc::Terminal
INPUT_BUFFER_SIZE	lexer.cpp	8;"	d	file:
INT	include/parser.h	/^    INT,$/;"	m	class:ccc::Type
INT_LITERAL	include/utility.h	/^    INT_LITERAL,$/;"	m	class:ccc::Terminal
INT_PTR	include/parser.h	/^    INT_PTR,$/;"	m	class:ccc::Type
INT_PTR	include/utility.h	/^    INT_PTR,$/;"	m	class:ccc::Terminal
IdAutomaton	include/lexer.h	/^class IdAutomaton : public FiniteAutomaton {$/;"	c	namespace:ccc
IdAutomaton	lexer.cpp	/^ccc::IdAutomaton::IdAutomaton()$/;"	f	class:ccc::IdAutomaton
IntLiteralAutomaton	include/lexer.h	/^class IntLiteralAutomaton : public FiniteAutomaton {$/;"	c	namespace:ccc
IntLiteralAutomaton	lexer.cpp	/^ccc::IntLiteralAutomaton::IntLiteralAutomaton()$/;"	f	class:ccc::IntLiteralAutomaton
LL1Parser	include/parser.h	/^class LL1Parser : public Parser {$/;"	c	namespace:ccc
LL1Parser	parser.cpp	/^ccc::LL1Parser::LL1Parser(SharedBuffer& buffer)$/;"	f	class:ccc::LL1Parser
LOGICAL_OP	include/utility.h	/^    LOGICAL_OP,$/;"	m	class:ccc::Terminal
Lexer	include/lexer.h	/^class Lexer {$/;"	c	namespace:ccc
Lexer	lexer.cpp	/^ccc::Lexer::Lexer()$/;"	f	class:ccc::Lexer
LogicalOpAutomaton	include/lexer.h	/^class LogicalOpAutomaton : public FiniteAutomaton {$/;"	c	namespace:ccc
LogicalOpAutomaton	lexer.cpp	/^ccc::LogicalOpAutomaton::LogicalOpAutomaton()$/;"	f	class:ccc::LogicalOpAutomaton
NON_TERMINAL	include/utility.h	/^    NON_TERMINAL,$/;"	m	class:ccc::Terminal
OPENING_BRACKET	include/utility.h	/^    OPENING_BRACKET,$/;"	m	class:ccc::Terminal
OPEN_SCOPE	include/utility.h	/^    OPEN_SCOPE,$/;"	m	class:ccc::Terminal
Parser	include/parser.h	/^class Parser {$/;"	c	namespace:ccc
Parser	parser.cpp	/^ccc::Parser::Parser(SharedBuffer& buffer)$/;"	f	class:ccc::Parser
SEMICOLON	include/utility.h	/^    SEMICOLON,$/;"	m	class:ccc::Terminal
STATIC	include/parser.h	/^    STATIC,$/;"	m	class:ccc::StorageSpecifier
STRING	include/parser.h	/^    STRING,$/;"	m	class:ccc::Type
STRING_LITERAL	include/utility.h	/^    STRING_LITERAL,$/;"	m	class:ccc::Terminal
STRING_PTR	include/parser.h	/^    STRING_PTR,$/;"	m	class:ccc::Type
ScopeAutomaton	include/lexer.h	/^class ScopeAutomaton : public FiniteAutomaton {$/;"	c	namespace:ccc
ScopeAutomaton	lexer.cpp	/^ccc::ScopeAutomaton::ScopeAutomaton()$/;"	f	class:ccc::ScopeAutomaton
SemicolonAutomaton	include/lexer.h	/^class SemicolonAutomaton : public FiniteAutomaton {$/;"	c	namespace:ccc
SemicolonAutomaton	lexer.cpp	/^ccc::SemicolonAutomaton::SemicolonAutomaton()$/;"	f	class:ccc::SemicolonAutomaton
SharedBuffer	include/utility.h	/^class SharedBuffer {$/;"	c	namespace:ccc
SharedBuffer	utility.cpp	/^ccc::SharedBuffer::SharedBuffer()$/;"	f	class:ccc::SharedBuffer
StackBasedVM	include/vm.h	/^class StackBasedVM : public VM {$/;"	c	namespace:ccc
StackBasedVM	vm.cpp	/^ccc::StackBasedVM::StackBasedVM(SyntaxTree& ast)$/;"	f	class:ccc::StackBasedVM
StorageSpecifier	include/parser.h	/^enum class StorageSpecifier {$/;"	c	namespace:ccc
StringLiteralAutomaton	include/lexer.h	/^class StringLiteralAutomaton : public FiniteAutomaton {$/;"	c	namespace:ccc
StringLiteralAutomaton	lexer.cpp	/^ccc::StringLiteralAutomaton::StringLiteralAutomaton()$/;"	f	class:ccc::StringLiteralAutomaton
Symbol	include/parser.h	/^struct Symbol {$/;"	s	namespace:ccc
Symbol	parser.cpp	/^ccc::Symbol::Symbol(Type type, StorageSpecifier storageSpecifier)$/;"	f	class:ccc::Symbol
SymbolTable	include/parser.h	/^class SymbolTable {$/;"	c	namespace:ccc
SymbolTable	parser.cpp	/^ccc::SymbolTable::SymbolTable()$/;"	f	class:ccc::SymbolTable
SyntaxTree	include/parser.h	/^class SyntaxTree {$/;"	c	namespace:ccc
SyntaxTree	parser.cpp	/^ccc::SyntaxTree::SyntaxTree()$/;"	f	class:ccc::SyntaxTree
SyntaxTreeNode	include/parser.h	/^    struct SyntaxTreeNode {$/;"	s	class:ccc::SyntaxTree
SyntaxTreeNode	parser.cpp	/^ccc::SyntaxTree::SyntaxTreeNode::SyntaxTreeNode(Token val)$/;"	f	class:ccc::SyntaxTree::SyntaxTreeNode
Terminal	include/utility.h	/^enum class Terminal {$/;"	c	namespace:ccc
Token	include/utility.h	/^struct Token {$/;"	s	namespace:ccc
Token	lexer.cpp	/^ccc::Token::Token(std::string lexeme, Terminal term)$/;"	f	class:ccc::Token
Type	include/parser.h	/^enum class Type {$/;"	c	namespace:ccc
VM	include/vm.h	/^class VM {$/;"	c	namespace:ccc
acceptingStates	include/lexer.h	/^    std::unordered_set<unsigned int> acceptingStates;$/;"	m	class:ccc::FiniteAutomaton
addScope	parser.cpp	/^void ccc::SymbolTable::addScope()$/;"	f	class:ccc::SymbolTable
addToSymbolTable	parser.cpp	/^void ccc::Parser::addToSymbolTable(ccc::Token& token, ccc::Type type)$/;"	f	class:ccc::Parser
ast	include/vm.h	/^    SyntaxTree& ast;$/;"	m	class:ccc::StackBasedVM
binaryOp	vm.cpp	/^bool ccc::StackBasedVM::binaryOp(Token token)$/;"	f	class:ccc::StackBasedVM
buffer	include/parser.h	/^    SharedBuffer& buffer;$/;"	m	class:ccc::Parser
buffer	include/utility.h	/^    std::queue<Token*> buffer;$/;"	m	class:ccc::SharedBuffer
calc	vm.cpp	/^T ccc::StackBasedVM::calc(T firstOperand, T secondOperand, Terminal term)$/;"	f	class:ccc::StackBasedVM
ccc	include/lexer.h	/^namespace ccc {$/;"	n
ccc	include/parser.h	/^namespace ccc {$/;"	n
ccc	include/utility.h	/^namespace ccc {$/;"	n
ccc	include/vm.h	/^namespace ccc {$/;"	n
children	include/parser.h	/^        SyntaxTreeNode* children;$/;"	m	struct:ccc::SyntaxTree::SyntaxTreeNode
condition	include/utility.h	/^    std::condition_variable condition;$/;"	m	class:ccc::SharedBuffer
consume	utility.cpp	/^ccc::Token* ccc::SharedBuffer::consume()$/;"	f	class:ccc::SharedBuffer
continueGrammarMatching	parser.cpp	/^void ccc::LL1Parser::continueGrammarMatching()$/;"	f	class:ccc::LL1Parser
convertToAst	parser.cpp	/^void ccc::LL1Parser::convertToAst(SyntaxTree& st)$/;"	f	class:ccc::LL1Parser
convertToAstHelper	parser.cpp	/^ccc::SyntaxTree::SyntaxTreeNode* ccc::LL1Parser::convertToAstHelper(SyntaxTree::SyntaxTreeNode* node)$/;"	f	class:ccc::LL1Parser
count	include/utility.h	/^    unsigned long long count;$/;"	m	class:ccc::SharedBuffer
currentState	include/lexer.h	/^    unsigned int currentState;$/;"	m	class:ccc::FiniteAutomaton
dispatchTable	include/vm.h	/^    std::unordered_map<Terminal, bool (ccc::StackBasedVM::*)(Token)> dispatchTable;$/;"	m	class:ccc::StackBasedVM
eval	vm.cpp	/^bool ccc::StackBasedVM::eval(SyntaxTree::SyntaxTreeNode* node)$/;"	f	class:ccc::StackBasedVM
expandProduction	parser.cpp	/^void ccc::LL1Parser::expandProduction(SyntaxTree& st)$/;"	f	class:ccc::LL1Parser
getTerminal	lexer.cpp	/^ccc::Terminal ccc::ArithmeticOpAutomaton::getTerminal() const$/;"	f	class:ccc::ArithmeticOpAutomaton
getTerminal	lexer.cpp	/^ccc::Terminal ccc::AssignmentOpAutomaton::getTerminal() const$/;"	f	class:ccc::AssignmentOpAutomaton
getTerminal	lexer.cpp	/^ccc::Terminal ccc::BracketAutomaton::getTerminal() const$/;"	f	class:ccc::BracketAutomaton
getTerminal	lexer.cpp	/^ccc::Terminal ccc::BuiltinTypeAutomaton::getTerminal() const$/;"	f	class:ccc::BuiltinTypeAutomaton
getTerminal	lexer.cpp	/^ccc::Terminal ccc::ControlFlowAutomaton::getTerminal() const$/;"	f	class:ccc::ControlFlowAutomaton
getTerminal	lexer.cpp	/^ccc::Terminal ccc::FloatLiteralAutomaton::getTerminal() const$/;"	f	class:ccc::FloatLiteralAutomaton
getTerminal	lexer.cpp	/^ccc::Terminal ccc::IdAutomaton::getTerminal() const$/;"	f	class:ccc::IdAutomaton
getTerminal	lexer.cpp	/^ccc::Terminal ccc::IntLiteralAutomaton::getTerminal() const$/;"	f	class:ccc::IntLiteralAutomaton
getTerminal	lexer.cpp	/^ccc::Terminal ccc::LogicalOpAutomaton::getTerminal() const$/;"	f	class:ccc::LogicalOpAutomaton
getTerminal	lexer.cpp	/^ccc::Terminal ccc::ScopeAutomaton::getTerminal() const$/;"	f	class:ccc::ScopeAutomaton
getTerminal	lexer.cpp	/^ccc::Terminal ccc::SemicolonAutomaton::getTerminal() const$/;"	f	class:ccc::SemicolonAutomaton
getTerminal	lexer.cpp	/^ccc::Terminal ccc::StringLiteralAutomaton::getTerminal() const$/;"	f	class:ccc::StringLiteralAutomaton
grammarSymbols	include/parser.h	/^    std::stack<std::string> grammarSymbols;$/;"	m	class:ccc::Parser
helperStack	include/parser.h	/^    std::stack<std::unordered_map<std::string, Symbol>*> helperStack;$/;"	m	class:ccc::SymbolTable
insert	parser.cpp	/^bool ccc::SymbolTable::insert(const std::string& symbolName, const Symbol& symbol)$/;"	f	class:ccc::SymbolTable
insert	parser.cpp	/^bool ccc::SyntaxTree::insert(const std::string& parentNonTerminal, const std::vector<Token>& tokens)$/;"	f	class:ccc::SyntaxTree
levelOrderTraversal	parser.cpp	/^void ccc::SyntaxTree::levelOrderTraversal(SyntaxTreeNode* node, unsigned int level,std::vector<std::vector<SyntaxTreeNode*>>& levels)$/;"	f	class:ccc::SyntaxTree
lexeme	include/utility.h	/^    std::string lexeme;$/;"	m	struct:ccc::Token
lookup	parser.cpp	/^bool ccc::SymbolTable::lookup(const std::string& symbolName, Symbol& outSymbol)$/;"	f	class:ccc::SymbolTable
m	include/utility.h	/^    std::mutex m;$/;"	m	class:ccc::SharedBuffer
main	main.cpp	/^int main(int argc, char** argv)$/;"	f
next	include/parser.h	/^        SyntaxTreeNode* next;$/;"	m	struct:ccc::SyntaxTree::SyntaxTreeNode
nonTerminalsToNodes	include/parser.h	/^    std::unordered_map<std::string, std::deque<SyntaxTreeNode*>> nonTerminalsToNodes;$/;"	m	class:ccc::SyntaxTree
operands	include/vm.h	/^    std::stack<Token> operands;$/;"	m	class:ccc::StackBasedVM
operator ==	lexer.cpp	/^bool ccc::Token::operator==(const Token& other) const$/;"	f	class:ccc::Token
override	include/lexer.h	/^    Terminal getTerminal() const override;$/;"	m	class:ccc::ArithmeticOpAutomaton
override	include/lexer.h	/^    Terminal getTerminal() const override;$/;"	m	class:ccc::AssignmentOpAutomaton
override	include/lexer.h	/^    Terminal getTerminal() const override;$/;"	m	class:ccc::BracketAutomaton
override	include/lexer.h	/^    Terminal getTerminal() const override;$/;"	m	class:ccc::BuiltinTypeAutomaton
override	include/lexer.h	/^    Terminal getTerminal() const override;$/;"	m	class:ccc::ControlFlowAutomaton
override	include/lexer.h	/^    Terminal getTerminal() const override;$/;"	m	class:ccc::FloatLiteralAutomaton
override	include/lexer.h	/^    Terminal getTerminal() const override;$/;"	m	class:ccc::IdAutomaton
override	include/lexer.h	/^    Terminal getTerminal() const override;$/;"	m	class:ccc::IntLiteralAutomaton
override	include/lexer.h	/^    Terminal getTerminal() const override;$/;"	m	class:ccc::LogicalOpAutomaton
override	include/lexer.h	/^    Terminal getTerminal() const override;$/;"	m	class:ccc::ScopeAutomaton
override	include/lexer.h	/^    Terminal getTerminal() const override;$/;"	m	class:ccc::SemicolonAutomaton
override	include/lexer.h	/^    Terminal getTerminal() const override;$/;"	m	class:ccc::StringLiteralAutomaton
override	include/parser.h	/^    bool parse(SyntaxTree& res) override;$/;"	m	class:ccc::LL1Parser
override	include/parser.h	/^    void convertToAst(SyntaxTree& st) override;$/;"	m	class:ccc::LL1Parser
override	include/vm.h	/^    void run() override;$/;"	m	class:ccc::StackBasedVM
parse	parser.cpp	/^bool ccc::LL1Parser::parse(SyntaxTree& res)$/;"	f	class:ccc::LL1Parser
parsingTable	include/parser.h	/^    std::unordered_map<std::string, std::unordered_map<Terminal, std::vector<std::string>>> parsingTable;$/;"	m	class:ccc::Parser
pop	utility.cpp	/^void ccc::SharedBuffer::pop()$/;"	f	class:ccc::SharedBuffer
printSyntaxTree	parser.cpp	/^void ccc::SyntaxTree::printSyntaxTree()$/;"	f	class:ccc::SyntaxTree
produce	utility.cpp	/^void ccc::SharedBuffer::produce(Token* token)$/;"	f	class:ccc::SharedBuffer
productionsToTerminals	include/parser.h	/^    const static std::unordered_map<std::string, Terminal> productionsToTerminals;$/;"	m	class:ccc::Parser
productionsToTerminals	parser.cpp	/^const std::unordered_map<std::string, ccc::Terminal> ccc::Parser::productionsToTerminals = {$/;"	m	class:ccc::Parser	file:
pushOperand	vm.cpp	/^bool ccc::StackBasedVM::pushOperand(Token token)$/;"	f	class:ccc::StackBasedVM
reloadInputBuffer	lexer.cpp	/^static void reloadInputBuffer(std::streamsize& current, std::streamsize starting, std::streamsize& numReadChars, char*& inputBuffer, std::ifstream& file)$/;"	f	file:
removeScope	parser.cpp	/^void ccc::SymbolTable::removeScope()$/;"	f	class:ccc::SymbolTable
root	include/parser.h	/^    SyntaxTreeNode* root;$/;"	m	class:ccc::SyntaxTree
run	lexer.cpp	/^bool ccc::Lexer::run(const std::string& filePath, SharedBuffer& buffer)$/;"	f	class:ccc::Lexer
run	vm.cpp	/^void ccc::StackBasedVM::run()$/;"	f	class:ccc::StackBasedVM
storageSpecifier	include/parser.h	/^    StorageSpecifier storageSpecifier;$/;"	m	struct:ccc::Symbol
symbolTable	include/parser.h	/^    SymbolTable symbolTable;$/;"	m	class:ccc::Parser
symbols	include/parser.h	/^    std::stack<std::unordered_map<std::string, Symbol>*> symbols;$/;"	m	class:ccc::SymbolTable
term	include/utility.h	/^    Terminal term;$/;"	m	struct:ccc::Token
terminals	include/parser.h	/^    std::unordered_set<std::string> terminals;$/;"	m	class:ccc::Parser
terminalsToProductions	include/parser.h	/^    const static std::unordered_map<Terminal, std::string> terminalsToProductions;$/;"	m	class:ccc::Parser
terminalsToProductions	parser.cpp	/^const std::unordered_map<ccc::Terminal, std::string> ccc::Parser::terminalsToProductions = {$/;"	m	class:ccc::Parser	file:
transition	lexer.cpp	/^bool ccc::FiniteAutomaton::transition(char input)$/;"	f	class:ccc::FiniteAutomaton
transitionTable	include/lexer.h	/^    std::unordered_map<char, std::unordered_map<unsigned int, unsigned int>> transitionTable;$/;"	m	class:ccc::FiniteAutomaton
type	include/parser.h	/^    Type type;$/;"	m	struct:ccc::Symbol
val	include/parser.h	/^        Token val;$/;"	m	struct:ccc::SyntaxTree::SyntaxTreeNode
~SharedBuffer	utility.cpp	/^ccc::SharedBuffer::~SharedBuffer()$/;"	f	class:ccc::SharedBuffer
~SymbolTable	parser.cpp	/^ccc::SymbolTable::~SymbolTable()$/;"	f	class:ccc::SymbolTable
~SyntaxTree	parser.cpp	/^ccc::SyntaxTree::~SyntaxTree()$/;"	f	class:ccc::SyntaxTree
~SyntaxTreeNode	parser.cpp	/^ccc::SyntaxTree::SyntaxTreeNode::~SyntaxTreeNode()$/;"	f	class:ccc::SyntaxTree::SyntaxTreeNode
